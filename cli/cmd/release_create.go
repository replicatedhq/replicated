package cmd

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/bmatcuk/doublestar/v4"
	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/google/uuid"
	"github.com/manifoldco/promptui"
	"github.com/pkg/errors"
	"github.com/replicatedhq/replicated/client"
	kotstypes "github.com/replicatedhq/replicated/pkg/kots/release/types"
	"github.com/replicatedhq/replicated/pkg/logger"
	"github.com/replicatedhq/replicated/pkg/tools"
	"github.com/replicatedhq/replicated/pkg/types"
	"github.com/spf13/cobra"
	"helm.sh/helm/v3/pkg/chart/loader"
)

const (
	defaultYAMLDir = "manifests"
)

func (r *runners) InitReleaseCreate(parent *cobra.Command) error {
	cmd := &cobra.Command{
		Use:   "create",
		Short: "Create a new release",
		Long: `Create a new release by providing application manifests for the next release in
  your sequence.

  If no flags are provided, the command will automatically use the configuration from
  .replicated file in the current directory (or parent directories). The config should
  specify charts and manifests to include. Charts will be automatically packaged using
  helm, and manifests will be collected using glob patterns.

  Example .replicated config:
    appSlug: "my-app"
    charts:
      - path: ./chart
    manifests:
      - ./manifests/*.yaml

  With this config, simply run:
    replicated release create --version 1.0.0 --promote Unstable`,
		SilenceUsage:  false,
		SilenceErrors: true, // this command uses custom error printing
	}

	parent.AddCommand(cmd)

	cmd.Flags().StringVar(&r.args.createReleaseYaml, "yaml", "", "The YAML config for this release. Use '-' to read from stdin. Cannot be used with the --yaml-file flag.")
	cmd.Flags().StringVar(&r.args.createReleaseYamlFile, "yaml-file", "", "The file name with YAML config for this release. Cannot be used with the --yaml flag.")
	cmd.Flags().StringVar(&r.args.createReleaseYamlDir, "yaml-dir", "", "The directory containing multiple yamls for a Kots release. Cannot be used with the --yaml flag.")
	cmd.Flags().StringVar(&r.args.createReleaseChart, "chart", "", "Helm chart to create the release from. Cannot be used with the --yaml, --yaml-file, or --yaml-dir flags.")
	cmd.Flags().StringVar(&r.args.createReleasePromote, "promote", "", "Channel name (case sensitive) or id to promote this release to")
	cmd.Flags().StringVar(&r.args.createReleasePromoteNotes, "release-notes", "", "When used with --promote <channel>, sets the **markdown** release notes")
	cmd.Flags().StringVar(&r.args.createReleasePromoteVersion, "version", "", "When used with --promote <channel>, sets the version label for the release in this channel")
	// Fail-on linting flag (from release_lint.go)
	cmd.Flags().StringVar(&r.args.lintReleaseFailOn, "fail-on", "error", "The minimum severity to cause the command to exit with a non-zero exit code. Supported values are [info, warn, error, none].")
	// Replicated release create lint flag
	cmd.Flags().BoolVar(&r.args.createReleaseLint, "lint", false, "Lint a manifests directory prior to creation of the KOTS Release.")
	cmd.Flags().BoolVar(&r.args.createReleasePromoteRequired, "required", false, "When used with --promote <channel>, marks this release as required during upgrades.")
	cmd.Flags().BoolVar(&r.args.createReleasePromoteEnsureChannel, "ensure-channel", false, "When used with --promote <channel>, will create the channel if it doesn't exist")
	cmd.Flags().BoolVar(&r.args.createReleaseAutoDefaults, "auto", false, "generate default values for use in CI")
	cmd.Flags().BoolVarP(&r.args.createReleaseAutoDefaultsAccept, "confirm-auto", "y", false, "auto-accept the configuration generated by the --auto flag")

	// output format
	cmd.Flags().StringVarP(&r.outputFormat, "output", "o", "table", "The output format to use. One of: json|table")

	// not supported for KOTS
	cmd.Flags().MarkHidden("required")
	cmd.Flags().MarkHidden("yaml-file")
	cmd.Flags().MarkHidden("yaml")
	cmd.Flags().MarkHidden("chart")

	// Override parent's PersistentPreRunE to handle config-based flow
	// The parent prerun tries to resolve app from cache/env which may fail
	// when using a different profile. For config flow, we'll resolve the app ourselves.
	originalPreRun := parent.PersistentPreRunE
	cmd.PreRunE = func(cmd *cobra.Command, args []string) error {
		// Check if we're using config-based flow
		// Note: --auto flag will set yaml-dir later, so don't use config flow when --auto is specified
		useConfigFlow := r.args.createReleaseYaml == "" &&
			r.args.createReleaseYamlFile == "" &&
			r.args.createReleaseYamlDir == "" &&
			r.args.createReleaseChart == "" &&
			!r.args.createReleaseAutoDefaults

		if useConfigFlow {
			// For config flow, temporarily clear app state before calling parent prerun
			// This prevents the parent from trying to resolve a cached/env app that doesn't exist in this profile
			savedAppID := r.appID
			savedAppSlug := r.appSlug
			savedAppType := r.appType

			r.appID = ""
			r.appSlug = ""
			r.appType = ""

			// Call parent prerun (will setup APIs but skip app resolution since app is empty)
			if originalPreRun != nil {
				if err := originalPreRun(cmd, args); err != nil {
					// Restore values
					r.appID = savedAppID
					r.appSlug = savedAppSlug
					r.appType = savedAppType
					return err
				}
			}

			// Keep app cleared - we'll load from config in releaseCreate
			return nil
		}

		// Non-config flow: use normal parent prerun
		if originalPreRun != nil {
			return originalPreRun(cmd, args)
		}
		return nil
	}

	cmd.RunE = r.releaseCreate
	return nil
}

func (r *runners) gitSHABranch() (sha string, branch string, dirty bool, err error) {
	path := "."
	rev := "HEAD"
	repository, err := git.PlainOpenWithOptions(path, &git.PlainOpenOptions{DetectDotGit: true})
	if err != nil {
		return "", "", false, fmt.Errorf("git open '%q' failed: %w", path, err)
	}
	h, err := repository.ResolveRevision(plumbing.Revision(rev))
	if err != nil {
		return "", "", false, fmt.Errorf("git resolve revision '%q' failed: %w", rev, err)
	}
	head, err := repository.Head()
	if err != nil {
		return "", "", false, fmt.Errorf("git resolve HEAD failed: %w", err)
	}

	worktree, err := repository.Worktree()
	if err != nil {
		return "", "", false, fmt.Errorf("git get worktree failed: %w", err)
	}
	status, err := worktree.Status()
	if err != nil {
		return "", "", false, fmt.Errorf("git get status failed: %w", err)
	}

	branchName := head.Name().Short()

	// for GH Actions, prefer env branch
	envBranch := os.Getenv("GITHUB_BRANCH_NAME")
	if envBranch != "" {
		branchName = envBranch
	}

	return h.String()[0:7], branchName, !status.IsClean(), nil
}

func (r *runners) setKOTSDefaultReleaseParams() error {
	if r.args.createReleaseYamlDir == "" {
		r.args.createReleaseYamlDir = "./manifests"
	}

	rev, branch, isDirty, err := r.gitSHABranch()
	if err != nil {
		return errors.Wrapf(err, "get git properties")
	}
	dirtyStatus := ""
	if isDirty {
		dirtyStatus = "-dirty"
	}

	if r.args.createReleasePromoteNotes == "" {
		// set some default release notes
		r.args.createReleasePromoteNotes = fmt.Sprintf(
			`CLI release of %s triggered by %s [SHA: %s%s] [%s]`,
			branch,
			os.Getenv("USER"),
			rev,
			dirtyStatus,
			time.Now().Format(time.RFC822),
		)
		// unless it's GH actions, then we can link to the commit! yay!
		if os.Getenv("GITHUB_ACTIONS") != "" {
			r.args.createReleasePromoteNotes = fmt.Sprintf(
				`GitHub Action release of %s triggered by %s: [%s](https://github.com/%s/commit/%s)`,
				os.Getenv("GITHUB_REF"),
				os.Getenv("GITHUB_ACTOR"),
				os.Getenv("GITHUB_SHA")[0:7],
				os.Getenv("GITHUB_REPOSITORY"),
				os.Getenv("GITHUB_SHA"),
			)
		}
	}

	if r.args.createReleasePromote == "" {
		r.args.createReleasePromote = branch
		if branch == "master" || branch == "main" {
			r.args.createReleasePromote = "Unstable"
		}
	}

	if r.args.createReleasePromoteVersion == "" {
		r.args.createReleasePromoteVersion = fmt.Sprintf("%s-%s%s", r.args.createReleasePromote, rev, dirtyStatus)
	}

	r.args.createReleasePromoteEnsureChannel = true
	r.args.createReleaseLint = true

	return nil
}

func (r *runners) releaseCreate(cmd *cobra.Command, args []string) (err error) {
	defer func() {
		printIfError(cmd, err)
	}()

	log := logger.NewLogger(r.w)
	if r.outputFormat == "json" {
		// suppress log lines for machine-readable output
		log.Silence()
	}

	// Check if we should use config-based flow (no explicit source flags provided)
	// Note: --auto flag will set yaml-dir later, so don't use config flow when --auto is specified
	useConfigFlow := r.args.createReleaseYaml == "" &&
		r.args.createReleaseYamlFile == "" &&
		r.args.createReleaseYamlDir == "" &&
		r.args.createReleaseChart == "" &&
		!r.args.createReleaseAutoDefaults

	var config *tools.Config
	var stagingDir string

	if useConfigFlow {
		// Try to find and parse .replicated config
		parser := tools.NewConfigParser()
		var configErr error
		config, configErr = parser.FindAndParseConfig(".")
		if configErr != nil {
			return errors.Wrap(configErr, "failed to find or parse .replicated config file")
		}

		// Check if config has any charts or manifests configured
		if len(config.Charts) == 0 && len(config.Manifests) == 0 {
			return errors.New("no charts or manifests configured in .replicated config file. Either configure them in .replicated or use --yaml-dir flag")
		}

		// Validate app ID/slug from config vs CLI flag
		if err := r.validateAppFromConfig(config); err != nil {
			return err
		}

		// After loading app from config, we need to re-resolve the app type
		// because the prerun might have run with a different app (from cache/env) before we loaded the config
		// Clear the appType to force a fresh resolution
		r.appType = ""
		if err := r.resolveAppType(); err != nil {
			return errors.Wrap(err, "resolve app type from config")
		}

		// Defer cleanup of staging directory
		defer func() {
			if stagingDir != "" {
				os.RemoveAll(stagingDir)
			}
		}()
	}

	// When using config flow, we've already loaded and resolved the app
	// For non-config flow, check if app was provided
	if !useConfigFlow && !r.hasApp() {
		return errors.New("no app specified")
	}

	if r.appType == "kots" && r.args.createReleaseAutoDefaults {
		log.ActionWithSpinner("Reading Environment")
		err = r.setKOTSDefaultReleaseParams()
		if err != nil {
			log.FinishSpinnerWithError()
			return errors.Wrap(err, "resolve kots defaults")
		}
		time.Sleep(500 * time.Millisecond)
		log.FinishSpinner()

		fmt.Fprintf(r.w, `
Prepared to create release with defaults:

    yaml-dir        %q
    promote         %q
    version         %q
    release-notes   %q
    ensure-channel  %t
    lint-release    %t

`, r.args.createReleaseYamlDir, r.args.createReleasePromote, r.args.createReleasePromoteVersion, r.args.createReleasePromoteNotes, r.args.createReleasePromoteEnsureChannel, r.args.createReleaseLint)
		if !r.args.createReleaseAutoDefaultsAccept {
			var confirmed string
			confirmed, err = promptForConfirm()
			if err != nil {
				return errors.Wrap(err, "prompt for confirm")
			}
			if strings.ToLower(confirmed) != "y" {
				return errors.New("configuration declined")
			}
			fmt.Printf("You can use the --confirm-auto or -y flag in the future to skip this prompt.\n")
		}
	}

	err = r.validateReleaseCreateParams()
	if err != nil {
		return errors.Wrap(err, "validate params")
	}

	// Check if --lint argument has been passed in by the enduser
	if r.args.createReleaseLint {
		// Request lint release yaml directory to check
		r.args.lintReleaseYamlDir = r.args.createReleaseYamlDir
		r.args.lintReleaseChart = r.args.createReleaseChart
		// Call release_lint.go releaseLint function
		err = r.releaseLint(cmd, args)
		if err != nil {
			return errors.Wrap(err, "lint yaml")
		}
	}

	if r.args.createReleaseYaml == "-" {
		var bytes []byte
		bytes, err = ioutil.ReadAll(r.stdin)
		if err != nil {
			return errors.Wrap(err, "read from stdin")
		}
		r.args.createReleaseYaml = string(bytes)
	}

	if r.args.createReleaseYamlFile != "" {
		var bytes []byte
		bytes, err = ioutil.ReadFile(r.args.createReleaseYamlFile)
		if err != nil {
			return errors.Wrap(err, "read file yaml")
		}
		r.args.createReleaseYaml = string(bytes)
	}

	if r.args.createReleaseYamlDir != "" {
		fmt.Fprintln(r.w)
		log.ActionWithSpinner("Reading manifests from %s", r.args.createReleaseYamlDir)
		var err error
		r.args.createReleaseYaml, err = makeReleaseFromDir(r.args.createReleaseYamlDir)
		if err != nil {
			log.FinishSpinnerWithError()
			return errors.Wrap(err, "make release from dir")
		}
		log.FinishSpinner()
	}

	// Handle config-based flow
	if useConfigFlow && config != nil {
		fmt.Fprintln(r.w)
		var err error
		stagingDir, r.args.createReleaseYaml, err = r.createReleaseFromConfig(config, log)
		if err != nil {
			return errors.Wrap(err, "create release from config")
		}
	}

	if r.args.createReleaseChart != "" {
		fmt.Fprint(r.w, "You are creating a release that will only be installable with the helm CLI.\n"+
			"For more information, see \n"+
			"https://docs.replicated.com/vendor/helm-install#about-helm-installations-with-replicated\n")
		fmt.Fprintln(r.w)
		log.ActionWithSpinner("Reading chart from %s", r.args.createReleaseChart)
		r.args.createReleaseYaml, err = makeReleaseFromChart(r.args.createReleaseChart)
		if err != nil {
			log.FinishSpinnerWithError()
			return errors.Wrap(err, "make release from chart")
		}
		log.FinishSpinner()
	}

	// if the --promote param was used make sure it identifies exactly one
	// channel before proceeding
	var promoteChanID string
	if r.args.createReleasePromote != "" {
		var err error
		promoteChanID, err = r.getOrCreateChannelForPromotion(
			r.args.createReleasePromote,
			r.args.createReleasePromoteEnsureChannel,
		)
		if err != nil {
			return errors.Wrapf(err, "get or create channel %q for promotion", promoteChanID)
		}
	}

	log.ActionWithSpinner("Creating Release")
	var release *types.ReleaseInfo
	release, err = r.api.CreateRelease(r.appID, r.appType, r.args.createReleaseYaml)
	if err != nil {
		log.FinishSpinnerWithError()
		return errors.Wrap(err, "create release")
	}
	log.FinishSpinner()

	if r.outputFormat == "json" {
		type createReleaseOutput struct {
			Sequence int64         `json:"sequence"`
			AppID    string        `json:"appId,omitempty"`
			Charts   []types.Chart `json:"charts,omitempty"`
		}
		out := createReleaseOutput{Sequence: release.Sequence, AppID: release.AppID, Charts: release.Charts}
		enc := json.NewEncoder(r.w)
		enc.SetIndent("", "  ")
		if err := enc.Encode(out); err != nil {
			return errors.Wrap(err, "encode json output")
		}
	} else {
		log.ChildActionWithoutSpinner("SEQUENCE: %d", release.Sequence)
	}

	if promoteChanID != "" {
		log.ActionWithSpinner("Promoting")
		if err = r.api.PromoteRelease(
			r.appID,
			r.appType,
			release.Sequence,
			r.args.createReleasePromoteVersion,
			r.args.createReleasePromoteNotes,
			r.args.createReleasePromoteRequired,
			promoteChanID,
		); err != nil {
			log.FinishSpinnerWithError()
			return errors.Wrap(err, "promote release")
		}
		log.FinishSpinner()

		// ignore error since operation was successful
		log.ChildActionWithoutSpinner("Channel %s successfully set to release %d\n", promoteChanID, release.Sequence)
	}

	return nil
}

func (r *runners) validateReleaseCreateParams() error {
	specSources := []string{
		r.args.createReleaseYaml,
		r.args.createReleaseYamlFile,
		r.args.createReleaseYamlDir,
		r.args.createReleaseChart,
	}

	numSources := 0
	for _, specSource := range specSources {
		if specSource != "" {
			numSources++
		}
	}

	// If no sources specified, config-based flow will be used (validated elsewhere)
	if numSources == 0 {
		return nil
	}

	if numSources > 1 {
		return errors.New("only one of --yaml, --yaml-file, --yaml-dir, or --chart may be specified")
	}

	if r.appType != "kots" {
		if r.args.createReleaseYaml == "" && r.args.createReleaseYamlFile == "" {
			return errors.New("one of --yaml or --yaml-file must be provided")
		}

		if (strings.HasSuffix(r.args.createReleaseYaml, ".yaml") || strings.HasSuffix(r.args.createReleaseYaml, ".yml")) &&
			len(strings.Split(r.args.createReleaseYaml, " ")) == 1 {
			return errors.New("use the --yaml-file flag when passing a yaml filename")
		}
	} else {
		if r.args.createReleaseYaml != "" {
			return errors.Errorf("the --yaml flag is not supported for KOTS applications, use --yaml-dir instead")
		}

		if r.args.createReleaseYamlFile != "" {
			return errors.Errorf("the --yaml-file flag is not supported for KOTS applications, use --yaml-dir instead")
		}
	}

	// can't ensure a channel if you didn't pass one
	if r.args.createReleasePromoteEnsureChannel && r.args.createReleasePromote == "" {
		return errors.New("cannot use the flag --ensure-channel without also using --promote <channel> ")
	}

	// we check this again below, but lets be explicit and fail fast
	if r.args.createReleasePromoteEnsureChannel && r.appType != "kots" {
		return errors.Errorf("the flag --ensure-channel is only supported for KOTS applications, app %q is of type %q", r.appID, r.appType)
	}

	return nil
}

func (r *runners) getOrCreateChannelForPromotion(channelName string, createIfAbsent bool) (string, error) {
	description := "" // todo: do we want a flag for the desired channel description

	opts := client.GetOrCreateChannelOptions{
		AppID:          r.appID,
		AppType:        r.appType,
		NameOrID:       channelName,
		Description:    description,
		CreateIfAbsent: createIfAbsent,
	}
	channel, err := r.api.GetOrCreateChannelByName(opts)
	if err != nil {
		return "", errors.Wrapf(err, "get-or-create channel %q", channelName)
	}

	return channel.ID, nil
}

func encodeKotsFile(prefix, path string, info os.FileInfo, err error) (*kotstypes.KotsSingleSpec, error) {
	if err != nil {
		return nil, err
	}

	singlefile := strings.TrimPrefix(filepath.Clean(path), filepath.Clean(prefix)+"/")

	if info.IsDir() {
		return nil, nil
	}
	if strings.HasPrefix(info.Name(), ".") {
		return nil, nil
	}
	ext := filepath.Ext(info.Name())
	if !isSupportedExt(ext) {
		return nil, nil
	}

	bytes, err := os.ReadFile(path)
	if err != nil {
		return nil, errors.Wrapf(err, "read file %s", path)
	}

	var str string
	switch ext {
	case ".tgz", ".gz", ".woff", ".woff2", ".ttf", ".otf", ".eot", ".svg":
		str = base64.StdEncoding.EncodeToString(bytes)
	default:
		str = string(bytes)
	}

	return &kotstypes.KotsSingleSpec{
		Name:     info.Name(),
		Path:     singlefile,
		Content:  str,
		Children: []kotstypes.KotsSingleSpec{},
	}, nil
}

func makeReleaseFromDir(fileDir string) (string, error) {
	fileInfo, err := os.Stat(fileDir)
	if err != nil {
		return "", errors.Wrapf(err, "stat %s", fileDir)
	}

	if !fileInfo.IsDir() {
		return "", errors.Errorf("path %s is not a directory", fileDir)
	}

	var allKotsReleaseSpecs []kotstypes.KotsSingleSpec
	err = filepath.Walk(fileDir, func(path string, info os.FileInfo, err error) error {
		spec, err := encodeKotsFile(fileDir, path, info, err)
		if err != nil {
			return err
		} else if spec == nil {
			return nil
		}
		allKotsReleaseSpecs = append(allKotsReleaseSpecs, *spec)
		return nil
	})
	if err != nil {
		return "", errors.Wrapf(err, "walk %s", fileDir)
	}

	jsonAllFiles, err := json.Marshal(allKotsReleaseSpecs)
	if err != nil {
		return "", errors.Wrap(err, "marshal spec")
	}
	return string(jsonAllFiles), nil
}

func makeReleaseFromChart(chartFile string) (string, error) {
	file, err := os.Open(chartFile)
	if err != nil {
		return "", errors.Wrapf(err, "open file")
	}
	defer file.Close()

	// Validate chart by loading it
	if _, err := loader.LoadArchive(file); err != nil {
		return "", errors.Wrapf(err, "load file")
	}

	fileInfo, err := file.Stat()
	if err != nil {
		return "", errors.Wrapf(err, "stat file")
	}

	dirName, _ := filepath.Split(chartFile)
	spec, err := encodeKotsFile(dirName, chartFile, fileInfo, nil)
	if err != nil {
		return "", errors.Wrap(err, "encode chart file")
	}

	if spec == nil {
		return "", errors.Errorf("chart file %s is not supported", chartFile)
	}

	allKotsReleaseSpecs := []kotstypes.KotsSingleSpec{
		*spec,
	}

	jsonAllFiles, err := json.Marshal(allKotsReleaseSpecs)
	if err != nil {
		return "", errors.Wrap(err, "marshal spec")
	}

	return string(jsonAllFiles), nil
}

func promptForConfirm() (string, error) {
	prompt := promptui.Prompt{
		Label:     "Create with these properties? (default Yes) [Y/n]",
		Templates: templates,
		Default:   "y",
		Validate: func(input string) error {
			switch strings.ToLower(input) {
			case "y", "n":
				return nil
			default:
				return errors.New(`please choose "y" or "n"`)
			}
		},
	}

	for {
		result, err := prompt.Run()
		if err != nil {
			if err == promptui.ErrInterrupt {
				return "", errors.New("interrupted")
			}
			continue
		}

		return result, nil
	}
}

func isSupportedExt(ext string) bool {
	switch ext {
	case ".tgz", ".gz", ".yaml", ".yml", ".css", ".woff", ".woff2", ".ttf", ".otf", ".eot", ".svg":
		return true
	default:
		return false
	}
}

// packageChart runs helm dependency update and helm package on a chart directory
// Returns the path to the packaged .tgz file
func packageChart(chartPath string) (string, error) {
	absChartPath, err := filepath.Abs(chartPath)
	if err != nil {
		return "", errors.Wrapf(err, "resolve absolute path for chart %s", chartPath)
	}

	// Check if chartPath is a directory containing Chart.yaml
	chartYAMLPath := filepath.Join(absChartPath, "Chart.yaml")
	if _, err := os.Stat(chartYAMLPath); err != nil {
		return "", errors.Wrapf(err, "chart directory %s must contain Chart.yaml", chartPath)
	}

	// Run helm dependency update
	depCmd := exec.Command("helm", "dependency", "update")
	depCmd.Dir = absChartPath
	depOutput, err := depCmd.CombinedOutput()
	if err != nil {
		return "", errors.Wrapf(err, "helm dependency update failed in %s: %s", chartPath, string(depOutput))
	}

	// Run helm package to create .tgz in the chart directory
	pkgCmd := exec.Command("helm", "package", ".")
	pkgCmd.Dir = absChartPath
	pkgOutput, err := pkgCmd.CombinedOutput()
	if err != nil {
		return "", errors.Wrapf(err, "helm package failed in %s: %s", chartPath, string(pkgOutput))
	}

	// Parse output to find the packaged .tgz filename
	// Output format: "Successfully packaged chart and saved it to: /path/to/chart-version.tgz"
	outputStr := string(pkgOutput)
	lines := strings.Split(outputStr, "\n")
	var tgzPath string
	for _, line := range lines {
		if strings.Contains(line, "Successfully packaged chart") && strings.Contains(line, ".tgz") {
			parts := strings.Split(line, ": ")
			if len(parts) >= 2 {
				tgzPath = strings.TrimSpace(parts[len(parts)-1])
				break
			}
		}
	}

	if tgzPath == "" {
		return "", errors.Errorf("could not determine packaged chart path from helm output: %s", outputStr)
	}

	// Verify the file exists
	if _, err := os.Stat(tgzPath); err != nil {
		return "", errors.Wrapf(err, "packaged chart file not found at %s", tgzPath)
	}

	return tgzPath, nil
}

// collectManifests resolves glob patterns and returns a list of manifest file paths
func collectManifests(patterns []string) ([]string, error) {
	var manifestPaths []string
	seenPaths := make(map[string]bool)

	for _, pattern := range patterns {
		// Resolve glob pattern
		matches, err := doublestar.FilepathGlob(pattern)
		if err != nil {
			return nil, errors.Wrapf(err, "invalid glob pattern %s", pattern)
		}

		for _, match := range matches {
			// Skip directories, only include files
			info, err := os.Stat(match)
			if err != nil {
				continue
			}
			if info.IsDir() {
				continue
			}

			// Deduplicate
			absPath, err := filepath.Abs(match)
			if err != nil {
				continue
			}
			if !seenPaths[absPath] {
				seenPaths[absPath] = true
				manifestPaths = append(manifestPaths, absPath)
			}
		}
	}

	return manifestPaths, nil
}

// createReleaseFromConfig creates a release from .replicated config file
// Returns the staging directory path for cleanup and the release YAML string
func (r *runners) createReleaseFromConfig(config *tools.Config, log *logger.Logger) (stagingDir string, releaseYAML string, err error) {
	// Create temporary staging directory
	stagingDir = filepath.Join(os.TempDir(), fmt.Sprintf("replicated-release-%s", uuid.New().String()))
	if err = os.MkdirAll(stagingDir, 0755); err != nil {
		return "", "", errors.Wrapf(err, "create staging directory %s", stagingDir)
	}

	// Package all charts
	log.ActionWithSpinner("Packaging charts")
	var packagedCharts []string
	for _, chart := range config.Charts {
		tgzPath, err := packageChart(chart.Path)
		if err != nil {
			log.FinishSpinnerWithError()
			return stagingDir, "", errors.Wrapf(err, "package chart %s", chart.Path)
		}
		packagedCharts = append(packagedCharts, tgzPath)
	}
	log.FinishSpinner()

	// Copy packaged charts to staging directory
	if len(packagedCharts) > 0 {
		log.ActionWithSpinner("Copying packaged charts to staging directory")
		for _, tgzPath := range packagedCharts {
			destPath := filepath.Join(stagingDir, filepath.Base(tgzPath))
			if err := copyFile(tgzPath, destPath); err != nil {
				log.FinishSpinnerWithError()
				return stagingDir, "", errors.Wrapf(err, "copy chart %s to staging", tgzPath)
			}
		}
		log.FinishSpinner()
	}

	// Collect and copy manifest files
	if len(config.Manifests) > 0 {
		log.ActionWithSpinner("Collecting manifest files")
		manifestPaths, err := collectManifests(config.Manifests)
		if err != nil {
			log.FinishSpinnerWithError()
			return stagingDir, "", errors.Wrap(err, "collect manifests")
		}
		log.FinishSpinner()

		if len(manifestPaths) > 0 {
			log.ActionWithSpinner("Copying manifests to staging directory")
			for _, manifestPath := range manifestPaths {
				destPath := filepath.Join(stagingDir, filepath.Base(manifestPath))
				if err := copyFile(manifestPath, destPath); err != nil {
					log.FinishSpinnerWithError()
					return stagingDir, "", errors.Wrapf(err, "copy manifest %s to staging", manifestPath)
				}
			}
			log.FinishSpinner()
		}
	}

	// Generate release YAML from staging directory
	log.ActionWithSpinner("Reading manifests from staging directory")
	releaseYAML, err = makeReleaseFromDir(stagingDir)
	if err != nil {
		log.FinishSpinnerWithError()
		return stagingDir, "", errors.Wrap(err, "make release from staging directory")
	}
	log.FinishSpinner()

	return stagingDir, releaseYAML, nil
}

// copyFile copies a file from src to dst
func copyFile(src, dst string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return errors.Wrapf(err, "open source file %s", src)
	}
	defer sourceFile.Close()

	destFile, err := os.Create(dst)
	if err != nil {
		return errors.Wrapf(err, "create destination file %s", dst)
	}
	defer destFile.Close()

	if _, err := destFile.ReadFrom(sourceFile); err != nil {
		return errors.Wrapf(err, "copy file from %s to %s", src, dst)
	}

	return nil
}

// resolveAppType resolves the app type by querying the API with the current appID or appSlug
func (r *runners) resolveAppType() error {
	if r.appID == "" && r.appSlug == "" {
		return nil // nothing to resolve
	}

	appSlugOrID := r.appSlug
	if appSlugOrID == "" {
		appSlugOrID = r.appID
	}

	app, appType, err := r.api.GetAppType(context.Background(), appSlugOrID, true)
	if err != nil {
		return errors.Wrapf(err, "get app type for %q", appSlugOrID)
	}

	r.appType = appType
	r.appID = app.ID
	r.appSlug = app.Slug

	return nil
}

// validateAppFromConfig validates that the app from config doesn't conflict with CLI --app flag
func (r *runners) validateAppFromConfig(config *tools.Config) error {
	configAppSlug := config.AppSlug
	configAppId := config.AppId

	// If config has an app configured
	if configAppSlug != "" || configAppId != "" {
		// If CLI --app flag was provided, validate it matches config
		if r.appID != "" || r.appSlug != "" {
			// Allow if CLI flag matches either the config's appId or appSlug
			// This handles cases where user passes appId and config has appSlug (or vice versa)
			// as long as they refer to the same app
			cliMatchesConfig := false

			// Check if CLI appID matches config appId
			if r.appID != "" && configAppId != "" && r.appID == configAppId {
				cliMatchesConfig = true
			}

			// Check if CLI appSlug matches config appSlug
			if r.appSlug != "" && configAppSlug != "" && r.appSlug == configAppSlug {
				cliMatchesConfig = true
			}

			// Check if CLI appID matches config appSlug (or vice versa)
			// We need to resolve this via API to check if they're the same app
			if r.appID != "" && configAppSlug != "" && !cliMatchesConfig {
				// The appID from CLI might be the ID for the slug in config
				// We'll allow this and let the API resolve it
				cliMatchesConfig = true
			}

			if r.appSlug != "" && configAppId != "" && !cliMatchesConfig {
				// The appSlug from CLI might be the slug for the ID in config
				// We'll allow this and let the API resolve it
				cliMatchesConfig = true
			}

			// If we couldn't match, show error with both values
			if !cliMatchesConfig {
				configValue := configAppSlug
				if configValue == "" {
					configValue = configAppId
				}
				cliValue := r.appSlug
				if cliValue == "" {
					cliValue = r.appID
				}
				return errors.Errorf("app mismatch: .replicated config specifies app %q but --app flag specifies %q. Remove --app flag or update .replicated config", configValue, cliValue)
			}
		} else {
			// No CLI flag provided, use app from config
			if config.AppSlug != "" {
				r.appSlug = config.AppSlug
			} else {
				r.appID = config.AppId
			}
		}
	}

	return nil
}
