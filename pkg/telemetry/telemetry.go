package telemetry

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/pkg/errors"
	"github.com/replicatedhq/replicated/pkg/platformclient"
	"github.com/spf13/cobra"
)

// Telemetry collects and sends CLI usage data
type Telemetry struct {
	client        *platformclient.HTTPClient
	disabled      bool
	eventID       string // UUID generated by CLI
	startTime     time.Time
	command       string
	hasConfigFile bool
	stats         *ResourceStats // Resource count statistics
}

// CheckAndPromptConsent checks if user has consented to telemetry and prompts if needed
// Returns true if telemetry should be enabled, false if disabled
// This should be called BEFORE initializing telemetry to ensure clean prompt
func CheckAndPromptConsent() bool {
	// Check if explicitly disabled via env var
	if os.Getenv("REPLICATED_TELEMETRY_DISABLED") == "true" {
		return false
	}

	// Check consent file or prompt user
	return checkTelemetryConsent()
}

// New creates a new telemetry instance (assumes consent already checked)
func New(apiToken string, origin string) *Telemetry {
	return &Telemetry{
		client:   platformclient.NewHTTPClient(origin, apiToken),
		disabled: false, // Disabled state handled by not calling New() at all
	}
}

// RecordCommandStart captures initial command data
func (t *Telemetry) RecordCommandStart(cmd *cobra.Command) {
	if t.disabled {
		return
	}

	// Generate UUID for this command execution
	// This is the event_id that will be sent to backend
	t.eventID = uuid.New().String()
	t.startTime = time.Now()
	t.command = cmd.CommandPath()
	t.hasConfigFile = checkConfigFileExists()
}

// RecordCommandComplete sends telemetry after command execution
func (t *Telemetry) RecordCommandComplete(cmd *cobra.Command, err error) {
	if t.disabled || t.eventID == "" {
		return
	}

	duration := time.Since(t.startTime)
	exitCode := 0

	// Capture error message before spawning goroutine to avoid race conditions
	var errMsg string
	if err != nil {
		exitCode = 1
		errMsg = err.Error()
	}

	// Fire and forget - don't block CLI execution
	go func() {
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		// Always send event
		if sendErr := t.sendEvent(ctx, exitCode, duration); sendErr != nil {
			debugLog("Failed to send telemetry event: %v", sendErr)
			return
		}

		// Send stats if available
		if sendErr := t.sendStats(ctx); sendErr != nil {
			debugLog("Failed to send telemetry stats: %v", sendErr)
			// Don't return - still try to send error if needed
		}

		// Send error details if command failed
		if exitCode != 0 && errMsg != "" {
			// Create error from captured message to avoid race conditions
			capturedErr := errors.New(errMsg)
			if sendErr := t.sendError(ctx, capturedErr); sendErr != nil {
				debugLog("Failed to send telemetry error: %v", sendErr)
			}
		}

		debugLog("Telemetry sent successfully")
	}()
}

// EventPayload matches backend's request structure
type EventPayload struct {
	EventID       string `json:"event_id"` // CLI generates UUID
	Command       string `json:"command"`
	ExitCode      *int   `json:"exit_code"`   // Pointer for nullable
	DurationMs    *int   `json:"duration_ms"` // Pointer for nullable
	HasConfigFile bool   `json:"has_config_file"`
}

// sendEvent sends command execution telemetry
func (t *Telemetry) sendEvent(ctx context.Context, exitCode int, duration time.Duration) error {
	// Convert to pointers for nullable fields
	exitCodePtr := &exitCode
	durationMs := int(duration.Milliseconds())
	durationMsPtr := &durationMs

	payload := EventPayload{
		EventID:       t.eventID,
		Command:       t.command,
		ExitCode:      exitCodePtr,
		DurationMs:    durationMsPtr,
		HasConfigFile: t.hasConfigFile,
	}

	debugLog("Sending event: command=%s, exit_code=%d, duration_ms=%d", t.command, exitCode, durationMs)

	// Backend returns {"event_id": "..."} but we don't need it (we generated it)
	return t.client.DoJSON(ctx, "POST", "/v3/cli/telemetry/event", 201, payload, nil)
}

// ErrorPayload matches backend's request structure
type ErrorPayload struct {
	EventID      string `json:"event_id"` // Links to event
	ErrorType    string `json:"error_type"`
	ErrorMessage string `json:"error_message"`
	Command      string `json:"command"`
}

// ResourceStats holds resource count statistics for a command
type ResourceStats struct {
	HelmChartsCount     int
	ManifestsCount      int
	PreflightsCount     int
	SupportBundlesCount int
	ToolVersions        map[string]string
}

// StatsPayload matches backend's request structure
type StatsPayload struct {
	Command        string            `json:"command"`
	HelmCharts     int               `json:"helm_charts"`
	K8sManifests   int               `json:"k8s_manifests"`
	Preflights     int               `json:"preflights"`
	SupportBundles int               `json:"support_bundles"`
	ToolVersions   map[string]string `json:"tool_versions"`
}

// sendError sends error telemetry
func (t *Telemetry) sendError(ctx context.Context, err error) error {
	payload := ErrorPayload{
		EventID:      t.eventID, // Links error to event
		ErrorType:    getErrorType(err),
		ErrorMessage: sanitizeErrorMessage(err.Error()),
		Command:      t.command,
	}

	debugLog("Sending error: event_id=%s, error_type=%s", t.eventID, getErrorType(err))

	return t.client.DoJSON(ctx, "POST", "/v3/cli/telemetry/error", 201, payload, nil)
}

// RecordStats stores resource statistics to be sent with telemetry
func (t *Telemetry) RecordStats(stats ResourceStats) {
	if t.disabled {
		debugLog("RecordStats called but telemetry disabled")
		return
	}
	t.stats = &stats
	debugLog("RecordStats: collected stats for command=%s (helm=%d, manifests=%d, preflights=%d, support_bundles=%d)",
		t.command, stats.HelmChartsCount, stats.ManifestsCount, stats.PreflightsCount, stats.SupportBundlesCount)
}

// sendStats sends resource statistics telemetry
func (t *Telemetry) sendStats(ctx context.Context) error {
	if t.stats == nil {
		return nil // No stats to send
	}

	payload := StatsPayload{
		Command:        t.command,
		HelmCharts:     t.stats.HelmChartsCount,
		K8sManifests:   t.stats.ManifestsCount,
		Preflights:     t.stats.PreflightsCount,
		SupportBundles: t.stats.SupportBundlesCount,
		ToolVersions:   t.stats.ToolVersions,
	}

	debugLog("Sending stats: helm_charts=%d, manifests=%d, preflights=%d, support_bundles=%d",
		t.stats.HelmChartsCount, t.stats.ManifestsCount, t.stats.PreflightsCount, t.stats.SupportBundlesCount)

	return t.client.DoJSON(ctx, "POST", "/v3/cli/telemetry/stats", 201, payload, nil)
}

// checkConfigFileExists checks if .replicated config file exists
func checkConfigFileExists() bool {
	// Check current directory
	if _, err := os.Stat(".replicated"); err == nil {
		return true
	}

	// Check home directory with proper path joining
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return false
	}

	if _, err := os.Stat(filepath.Join(homeDir, ".replicated")); err == nil {
		return true
	}

	return false
}

// sanitizeErrorMessage removes potentially sensitive data from error messages
func sanitizeErrorMessage(msg string) string {
	// Order matters! Process in this sequence to avoid conflicts

	// 1. Remove URLs with embedded credentials FIRST (before email pattern catches them)
	urlCredsPattern := regexp.MustCompile(`https?://[^:]+:[^@]+@[^\s]+`)
	msg = urlCredsPattern.ReplaceAllString(msg, "[URL]")

	// 2. Remove database/connection strings (enhanced to cover more protocols)
	connStringPattern := regexp.MustCompile(`(?i)(mongodb(\+srv)?|mysql|mariadb|postgresql|postgres|redis|mssql|oracle)://[^\s]+`)
	msg = connStringPattern.ReplaceAllString(msg, "$1://[CONNECTION]")

	// 3. Remove potential API tokens - Fixed to include glpat with dash or underscore separator
	tokenPattern := regexp.MustCompile(`\b(sk|ghp|gh[pousr]|pypi|npm)_[A-Za-z0-9_-]+|\bglpat[-_][A-Za-z0-9_-]+`)
	msg = tokenPattern.ReplaceAllString(msg, "[TOKEN]")

	// 4. Remove AWS access keys (AKIA...)
	awsKeyPattern := regexp.MustCompile(`AKIA[0-9A-Z]{16}`)
	msg = awsKeyPattern.ReplaceAllString(msg, "[AWS_KEY]")

	// 5. Remove email addresses (after URL credentials to avoid conflicts)
	emailPattern := regexp.MustCompile(`[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}`)
	msg = emailPattern.ReplaceAllString(msg, "[EMAIL]")

	// 6. Remove IPv4 addresses
	ipv4Pattern := regexp.MustCompile(`\b(?:\d{1,3}\.){3}\d{1,3}\b`)
	msg = ipv4Pattern.ReplaceAllString(msg, "[IP]")

	// 7. Remove IPv6 addresses - Fixed to handle :: notation properly
	ipv6Pattern := regexp.MustCompile(`\b(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}\b|` +
		`\b(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}\b|` +
		`\b(?:[0-9a-fA-F]{1,4}:){1,7}:\b|` +
		`\b::(?:[0-9a-fA-F]{1,4}:){0,6}[0-9a-fA-F]{1,4}\b|` +
		`\b[0-9a-fA-F]{1,4}::(?:[0-9a-fA-F]{1,4}:){0,5}[0-9a-fA-F]{1,4}\b|` +
		`\bfe80::[0-9a-fA-F:]+\b`)
	msg = ipv6Pattern.ReplaceAllString(msg, "[IP]")

	// 8. Remove file system paths - order matters, most specific first
	// Home directories (exact match)
	homePattern := regexp.MustCompile(`/(?:home|Users)/[^\s/]+`)
	msg = homePattern.ReplaceAllString(msg, "[HOME]")

	// Windows home directories
	windowsHomePattern := regexp.MustCompile(`C:\\Users\\[^\s\\]+`)
	msg = windowsHomePattern.ReplaceAllString(msg, "[HOME]")

	// Temp directories
	tempPattern := regexp.MustCompile(`/(?:tmp|var/tmp)/[^\s:]+`)
	msg = tempPattern.ReplaceAllString(msg, "[TEMP]")

	// Home-relative paths - Fixed to accept single segment (~/file.txt)
	homeRelativePattern := regexp.MustCompile(`~(?:/[^\s:]+){1,}`)
	msg = homeRelativePattern.ReplaceAllString(msg, "[PATH]")

	// Absolute file paths - Only match known filesystem roots to avoid API false positives
	// Fixed: Don't include leading space in replacement
	absolutePathPattern := regexp.MustCompile(`(?:^|\s)(/(usr|home|var|opt|etc|srv|tmp|mnt)(?:/[^\s:]+)+)`)
	msg = absolutePathPattern.ReplaceAllStringFunc(msg, func(match string) string {
		if strings.HasPrefix(match, " ") {
			return " [PATH]" // Preserve single space
		}
		return "[PATH]" // Start of string
	})

	// Windows paths - Fixed to handle spaces in paths (Program Files)
	windowsPathPattern := regexp.MustCompile(`[A-Z]:[\\][^\n:]+`)
	msg = windowsPathPattern.ReplaceAllString(msg, "[PATH]")

	// 9. Remove potential passwords/secrets - Fixed to handle colons and quotes properly
	// Matches: password=xxx, password:"xxx", password: xxx, api_key:xxx
	// Handle quoted values specially to avoid partial matches
	passwordPattern := regexp.MustCompile(`(?i)(password|passwd|pwd|secret|api[_-]key)[\s=:]+(?:"([^"]{1,100})"|'([^']{1,100})'|([^\s,;"'\n]{1,100}))`)
	msg = passwordPattern.ReplaceAllString(msg, "$1=[REDACTED]")

	return msg
}

// getErrorType extracts error type from error with improved categorization
func getErrorType(err error) string {
	cause := errors.Cause(err)

	// Check for specific error types
	switch cause.(type) {
	case platformclient.APIError:
		return "APIError"
	}

	// Categorize by error message patterns for better debugging
	errMsg := strings.ToLower(err.Error())

	// Network-related errors
	if strings.Contains(errMsg, "network") ||
		strings.Contains(errMsg, "connection") ||
		strings.Contains(errMsg, "dial tcp") ||
		strings.Contains(errMsg, "no such host") ||
		strings.Contains(errMsg, "dns") {
		return "NetworkError"
	}

	// Timeout/cancellation errors
	if strings.Contains(errMsg, "timeout") ||
		strings.Contains(errMsg, "timed out") ||
		strings.Contains(errMsg, "context deadline exceeded") ||
		strings.Contains(errMsg, "context canceled") {
		return "TimeoutError"
	}

	// TLS/Certificate errors
	if strings.Contains(errMsg, "certificate") ||
		strings.Contains(errMsg, "tls") ||
		strings.Contains(errMsg, "ssl") ||
		strings.Contains(errMsg, "x509") {
		return "TLSError"
	}

	// Not found errors
	if strings.Contains(errMsg, "not found") ||
		strings.Contains(errMsg, "does not exist") ||
		strings.Contains(errMsg, "no such file") {
		return "NotFoundError"
	}

	// Permission/authorization errors
	if strings.Contains(errMsg, "permission") ||
		strings.Contains(errMsg, "forbidden") ||
		strings.Contains(errMsg, "unauthorized") ||
		strings.Contains(errMsg, "access denied") {
		return "PermissionError"
	}

	// Parse/validation errors
	if strings.Contains(errMsg, "parse") ||
		strings.Contains(errMsg, "unmarshal") ||
		strings.Contains(errMsg, "decode") ||
		strings.Contains(errMsg, "invalid syntax") ||
		strings.Contains(errMsg, "invalid argument") {
		return "ValidationError"
	}

	return "Error"
}

// checkTelemetryConsent checks if user has consented to telemetry or prompts on first run
func checkTelemetryConsent() bool {
	// Check if consent file exists
	consentFile := getTelemetryConsentFile()

	// If file exists, read consent
	if _, err := os.Stat(consentFile); err == nil {
		data, err := os.ReadFile(consentFile)
		if err == nil {
			// File contains "enabled" or "disabled"
			consent := strings.TrimSpace(string(data))
			return consent == "enabled"
		}
	}

	// First run - prompt user
	return promptForTelemetryConsent(consentFile)
}

// getTelemetryConsentFile returns the path to the telemetry consent file
func getTelemetryConsentFile() string {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return ".replicated_telemetry"
	}
	return filepath.Join(homeDir, ".replicated", "telemetry_consent")
}

// promptForTelemetryConsent asks user for consent on first run
func promptForTelemetryConsent(consentFile string) bool {
	// Check if running in non-interactive mode (CI, piped, etc.)
	if os.Getenv("CI") == "true" || !isInteractive() {
		// In non-interactive mode, default to enabled (can opt-out via env var)
		saveConsent(consentFile, true)
		return true
	}

	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n")
	fmt.Fprintf(os.Stderr, "  üìä Help us improve the Replicated CLI\n")
	fmt.Fprintf(os.Stderr, "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n")
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "The Replicated CLI would like to collect anonymous usage data to help\n")
	fmt.Fprintf(os.Stderr, "us understand how the CLI is being used and improve the product.\n")
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "We collect:\n")
	fmt.Fprintf(os.Stderr, "  ‚Ä¢ Command names (e.g., 'release create', 'channel ls')\n")
	fmt.Fprintf(os.Stderr, "  ‚Ä¢ Command duration and success/failure\n")
	fmt.Fprintf(os.Stderr, "  ‚Ä¢ Environment (CI vs local)\n")
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "We DO NOT collect:\n")
	fmt.Fprintf(os.Stderr, "  ‚Ä¢ Command arguments or flags\n")
	fmt.Fprintf(os.Stderr, "  ‚Ä¢ File contents or app data\n")
	fmt.Fprintf(os.Stderr, "  ‚Ä¢ Personal information\n")
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "You can opt-out anytime by setting: REPLICATED_TELEMETRY_DISABLED=true\n")
	fmt.Fprintf(os.Stderr, "\n")
	fmt.Fprintf(os.Stderr, "Allow anonymous telemetry? [Y/n]: ")

	// Read user response
	var response string
	fmt.Fscanln(os.Stdin, &response)
	response = strings.ToLower(strings.TrimSpace(response))

	// Default to yes if empty (just pressed enter)
	enabled := response == "" || response == "y" || response == "yes"

	// Save consent
	saveConsent(consentFile, enabled)

	if enabled {
		fmt.Fprintf(os.Stderr, "‚úì Telemetry enabled. Thank you for helping improve the CLI!\n\n")
	} else {
		fmt.Fprintf(os.Stderr, "‚úì Telemetry disabled. You can enable it later by removing:\n")
		fmt.Fprintf(os.Stderr, "  %s\n\n", consentFile)
	}

	return enabled
}

// saveConsent saves the user's telemetry consent choice
func saveConsent(consentFile string, enabled bool) {
	// Ensure directory exists
	dir := filepath.Dir(consentFile)
	os.MkdirAll(dir, 0755)

	// Write consent
	consent := "disabled"
	if enabled {
		consent = "enabled"
	}
	os.WriteFile(consentFile, []byte(consent), 0644)
}

// isInteractive checks if running in an interactive terminal
func isInteractive() bool {
	// Check if stdin is a terminal
	fileInfo, err := os.Stdin.Stat()
	if err != nil {
		return false
	}
	return (fileInfo.Mode() & os.ModeCharDevice) != 0
}

// debugLog logs debug messages only if REPLICATED_DEBUG is set
func debugLog(format string, args ...interface{}) {
	if os.Getenv("REPLICATED_DEBUG") == "true" || os.Getenv("REPLICATED_DEBUG") == "1" {
		fmt.Fprintf(os.Stderr, "[TELEMETRY DEBUG] "+format+"\n", args...)
	}
}
