package telemetry

import (
	"context"
	"fmt"
	"os"
	"time"

	"github.com/google/uuid"
	"github.com/pkg/errors"
	"github.com/replicatedhq/replicated/pkg/platformclient"
	"github.com/spf13/cobra"
)

// Telemetry collects and sends CLI usage data
type Telemetry struct {
	client        *platformclient.HTTPClient
	disabled      bool
	eventID       string // UUID generated by CLI
	startTime     time.Time
	command       string
	hasConfigFile bool
}

// New creates a new telemetry instance
func New(apiToken string, origin string) *Telemetry {
	disabled := os.Getenv("REPLICATED_TELEMETRY_DISABLED") == "true"

	return &Telemetry{
		client:   platformclient.NewHTTPClient(origin, apiToken),
		disabled: disabled,
	}
}

// RecordCommandStart captures initial command data
func (t *Telemetry) RecordCommandStart(cmd *cobra.Command) {
	if t.disabled {
		return
	}

	// Generate UUID for this command execution
	// This is the event_id that will be sent to backend
	t.eventID = uuid.New().String()
	t.startTime = time.Now()
	t.command = cmd.CommandPath()
	t.hasConfigFile = checkConfigFileExists()
}

// RecordCommandComplete sends telemetry after command execution
func (t *Telemetry) RecordCommandComplete(cmd *cobra.Command, err error) {
	if t.disabled || t.eventID == "" {
		return
	}

	duration := time.Since(t.startTime)
	exitCode := 0
	if err != nil {
		exitCode = 1
	}

	// Fire and forget - don't block CLI execution
	go func() {
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		// Always send event
		if sendErr := t.sendEvent(ctx, exitCode, duration); sendErr != nil {
			debugLog("Failed to send telemetry event: %v", sendErr)
			return
		}

		// Send error details if command failed
		if exitCode != 0 && err != nil {
			if sendErr := t.sendError(ctx, err); sendErr != nil {
				debugLog("Failed to send telemetry error: %v", sendErr)
			}
		}

		debugLog("Telemetry sent successfully")
	}()
}

// EventPayload matches backend's request structure
type EventPayload struct {
	EventID       string `json:"event_id"` // CLI generates UUID
	Command       string `json:"command"`
	ExitCode      *int   `json:"exit_code"`   // Pointer for nullable
	DurationMs    *int   `json:"duration_ms"` // Pointer for nullable
	HasConfigFile bool   `json:"has_config_file"`
}

// sendEvent sends command execution telemetry
func (t *Telemetry) sendEvent(ctx context.Context, exitCode int, duration time.Duration) error {
	// Convert to pointers for nullable fields
	exitCodePtr := &exitCode
	durationMs := int(duration.Milliseconds())
	durationMsPtr := &durationMs

	payload := EventPayload{
		EventID:       t.eventID,
		Command:       t.command,
		ExitCode:      exitCodePtr,
		DurationMs:    durationMsPtr,
		HasConfigFile: t.hasConfigFile,
	}

	// Backend returns {"event_id": "..."} but we don't need it (we generated it)
	return t.client.DoJSON(ctx, "POST", "/v3/cli/telemetry/event", 201, payload, nil)
}

// ErrorPayload matches backend's request structure
type ErrorPayload struct {
	EventID      string `json:"event_id"` // Links to event
	ErrorType    string `json:"error_type"`
	ErrorMessage string `json:"error_message"`
	Command      string `json:"command"`
}

// sendError sends error telemetry
func (t *Telemetry) sendError(ctx context.Context, err error) error {
	payload := ErrorPayload{
		EventID:      t.eventID, // Links error to event
		ErrorType:    getErrorType(err),
		ErrorMessage: err.Error(),
		Command:      t.command,
	}

	return t.client.DoJSON(ctx, "POST", "/v3/cli/telemetry/error", 201, payload, nil)
}

// checkConfigFileExists checks if .replicated config file exists
func checkConfigFileExists() bool {
	// Check current directory
	if _, err := os.Stat(".replicated"); err == nil {
		return true
	}

	// Check home directory
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return false
	}

	if _, err := os.Stat(homeDir + "/.replicated"); err == nil {
		return true
	}

	return false
}

// getErrorType extracts error type from error
func getErrorType(err error) string {
	cause := errors.Cause(err)

	switch cause.(type) {
	case platformclient.APIError:
		return "APIError"
	default:
		return "Error"
	}
}

// debugLog logs debug messages only if REPLICATED_DEBUG is set
func debugLog(format string, args ...interface{}) {
	if os.Getenv("REPLICATED_DEBUG") == "true" || os.Getenv("REPLICATED_DEBUG") == "1" {
		fmt.Fprintf(os.Stderr, "[TELEMETRY DEBUG] "+format+"\n", args...)
	}
}
