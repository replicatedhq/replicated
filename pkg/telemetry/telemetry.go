package telemetry

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/pkg/errors"
	"github.com/replicatedhq/replicated/pkg/platformclient"
	"github.com/spf13/cobra"
)

// Telemetry collects and sends CLI usage data
type Telemetry struct {
	client        *platformclient.HTTPClient
	disabled      bool
	eventID       string // UUID generated by CLI
	startTime     time.Time
	command       string
	hasConfigFile bool
}

// New creates a new telemetry instance
func New(apiToken string, origin string) *Telemetry {
	disabled := os.Getenv("REPLICATED_TELEMETRY_DISABLED") == "true"

	return &Telemetry{
		client:   platformclient.NewHTTPClient(origin, apiToken),
		disabled: disabled,
	}
}

// RecordCommandStart captures initial command data
func (t *Telemetry) RecordCommandStart(cmd *cobra.Command) {
	if t.disabled {
		return
	}

	// Generate UUID for this command execution
	// This is the event_id that will be sent to backend
	t.eventID = uuid.New().String()
	t.startTime = time.Now()
	t.command = cmd.CommandPath()
	t.hasConfigFile = checkConfigFileExists()
}

// RecordCommandComplete sends telemetry after command execution
func (t *Telemetry) RecordCommandComplete(cmd *cobra.Command, err error) {
	if t.disabled || t.eventID == "" {
		return
	}

	duration := time.Since(t.startTime)
	exitCode := 0

	// Capture error message before spawning goroutine to avoid race conditions
	var errMsg string
	if err != nil {
		exitCode = 1
		errMsg = err.Error()
	}

	// Fire and forget - don't block CLI execution
	go func() {
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		// Always send event
		if sendErr := t.sendEvent(ctx, exitCode, duration); sendErr != nil {
			debugLog("Failed to send telemetry event: %v", sendErr)
			return
		}

		// Send error details if command failed
		if exitCode != 0 && errMsg != "" {
			// Create error from captured message to avoid race conditions
			capturedErr := errors.New(errMsg)
			if sendErr := t.sendError(ctx, capturedErr); sendErr != nil {
				debugLog("Failed to send telemetry error: %v", sendErr)
			}
		}

		debugLog("Telemetry sent successfully")
	}()
}

// EventPayload matches backend's request structure
type EventPayload struct {
	EventID       string `json:"event_id"` // CLI generates UUID
	Command       string `json:"command"`
	ExitCode      *int   `json:"exit_code"`   // Pointer for nullable
	DurationMs    *int   `json:"duration_ms"` // Pointer for nullable
	HasConfigFile bool   `json:"has_config_file"`
}

// sendEvent sends command execution telemetry
func (t *Telemetry) sendEvent(ctx context.Context, exitCode int, duration time.Duration) error {
	// Convert to pointers for nullable fields
	exitCodePtr := &exitCode
	durationMs := int(duration.Milliseconds())
	durationMsPtr := &durationMs

	payload := EventPayload{
		EventID:       t.eventID,
		Command:       t.command,
		ExitCode:      exitCodePtr,
		DurationMs:    durationMsPtr,
		HasConfigFile: t.hasConfigFile,
	}

	debugLog("Sending event: command=%s, exit_code=%d, duration_ms=%d", t.command, exitCode, durationMs)

	// Backend returns {"event_id": "..."} but we don't need it (we generated it)
	return t.client.DoJSON(ctx, "POST", "/v3/cli/telemetry/event", 201, payload, nil)
}

// ErrorPayload matches backend's request structure
type ErrorPayload struct {
	EventID      string `json:"event_id"` // Links to event
	ErrorType    string `json:"error_type"`
	ErrorMessage string `json:"error_message"`
	Command      string `json:"command"`
}

// sendError sends error telemetry
func (t *Telemetry) sendError(ctx context.Context, err error) error {
	payload := ErrorPayload{
		EventID:      t.eventID, // Links error to event
		ErrorType:    getErrorType(err),
		ErrorMessage: sanitizeErrorMessage(err.Error()),
		Command:      t.command,
	}

	debugLog("Sending error: event_id=%s, error_type=%s", t.eventID, getErrorType(err))

	return t.client.DoJSON(ctx, "POST", "/v3/cli/telemetry/error", 201, payload, nil)
}

// checkConfigFileExists checks if .replicated config file exists
func checkConfigFileExists() bool {
	// Check current directory
	if _, err := os.Stat(".replicated"); err == nil {
		return true
	}

	// Check home directory with proper path joining
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return false
	}

	if _, err := os.Stat(filepath.Join(homeDir, ".replicated")); err == nil {
		return true
	}

	return false
}

// sanitizeErrorMessage removes potentially sensitive data from error messages
func sanitizeErrorMessage(msg string) string {
	// Remove potential API tokens (sk_, ghp_, glpat_, npm_, pypi_, etc.)
	tokenPattern := regexp.MustCompile(`\b(sk|ghp|gh[pousr]|glpat|pypi|npm)_[A-Za-z0-9_-]+`)
	msg = tokenPattern.ReplaceAllString(msg, "[TOKEN]")

	// Remove AWS access keys (AKIA...)
	awsKeyPattern := regexp.MustCompile(`AKIA[0-9A-Z]{16}`)
	msg = awsKeyPattern.ReplaceAllString(msg, "[AWS_KEY]")

	// Remove email addresses
	emailPattern := regexp.MustCompile(`[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}`)
	msg = emailPattern.ReplaceAllString(msg, "[EMAIL]")

	// Remove URLs with embedded credentials (https://user:pass@host)
	urlCredsPattern := regexp.MustCompile(`https?://[^:]+:[^@]+@[^\s]+`)
	msg = urlCredsPattern.ReplaceAllString(msg, "[URL]")

	// Remove database/connection strings (enhanced to cover more protocols)
	connStringPattern := regexp.MustCompile(`(?i)(mongodb(\+srv)?|mysql|mariadb|postgresql|postgres|redis|mssql|oracle)://[^\s]+`)
	msg = connStringPattern.ReplaceAllString(msg, "$1://[CONNECTION]")

	// Remove IPv4 addresses
	ipv4Pattern := regexp.MustCompile(`\b(?:\d{1,3}\.){3}\d{1,3}\b`)
	msg = ipv4Pattern.ReplaceAllString(msg, "[IP]")

	// Remove IPv6 addresses (simplified pattern covering common formats)
	ipv6Pattern := regexp.MustCompile(`\b(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}\b|` +
		`\b(?:[0-9a-fA-F]{1,4}:){1,7}:\b|` +
		`\b:(?::[0-9a-fA-F]{1,4}){1,7}\b`)
	msg = ipv6Pattern.ReplaceAllString(msg, "[IP]")

	// Remove file system paths - conservative to avoid API path false positives
	// Focus on protecting actual filesystem locations
	// Home directories
	homePattern := regexp.MustCompile(`(?:/(?:home|Users)/[^\s/]+|C:\\Users\\[^\s\\]+)`)
	msg = homePattern.ReplaceAllString(msg, "[HOME]")

	// Temp directories
	tempPattern := regexp.MustCompile(`(?:/(?:tmp|var/tmp)/[^\s:]+)`)
	msg = tempPattern.ReplaceAllString(msg, "[TEMP]")

	// Absolute file paths with 3+ segments (likely filesystem, not API)
	absolutePathPattern := regexp.MustCompile(`(?:^|\s)(/[a-z]+(?:/[^\s:]+){2,})`)
	msg = absolutePathPattern.ReplaceAllString(msg, " [PATH]")

	// Windows paths with backslashes
	windowsPathPattern := regexp.MustCompile(`[A-Z]:\\[^\s]+`)
	msg = windowsPathPattern.ReplaceAllString(msg, "[PATH]")

	// Home-relative paths
	homeRelativePattern := regexp.MustCompile(`~(?:/[^\s:]+){2,}`)
	msg = homeRelativePattern.ReplaceAllString(msg, "[PATH]")

	// Remove potential passwords/secrets in error messages
	// Matches: password=xxx, password="xxx", password: xxx, api_key=xxx
	// Bounded to 100 chars to prevent runaway matching
	passwordPattern := regexp.MustCompile(`(?i)(password|passwd|pwd|secret|api[_-]?key)[\s=:]["']?([^\s,;"']{1,100})["']?`)
	msg = passwordPattern.ReplaceAllString(msg, "$1=[REDACTED]")

	return msg
}

// getErrorType extracts error type from error with improved categorization
func getErrorType(err error) string {
	cause := errors.Cause(err)

	// Check for specific error types
	switch cause.(type) {
	case platformclient.APIError:
		return "APIError"
	}

	// Categorize by error message patterns for better debugging
	errMsg := strings.ToLower(err.Error())

	// Network-related errors
	if strings.Contains(errMsg, "network") ||
		strings.Contains(errMsg, "connection") ||
		strings.Contains(errMsg, "dial tcp") ||
		strings.Contains(errMsg, "no such host") ||
		strings.Contains(errMsg, "dns") {
		return "NetworkError"
	}

	// Timeout/cancellation errors
	if strings.Contains(errMsg, "timeout") ||
		strings.Contains(errMsg, "timed out") ||
		strings.Contains(errMsg, "context deadline exceeded") ||
		strings.Contains(errMsg, "context canceled") {
		return "TimeoutError"
	}

	// TLS/Certificate errors
	if strings.Contains(errMsg, "certificate") ||
		strings.Contains(errMsg, "tls") ||
		strings.Contains(errMsg, "ssl") ||
		strings.Contains(errMsg, "x509") {
		return "TLSError"
	}

	// Not found errors
	if strings.Contains(errMsg, "not found") ||
		strings.Contains(errMsg, "does not exist") ||
		strings.Contains(errMsg, "no such file") {
		return "NotFoundError"
	}

	// Permission/authorization errors
	if strings.Contains(errMsg, "permission") ||
		strings.Contains(errMsg, "forbidden") ||
		strings.Contains(errMsg, "unauthorized") ||
		strings.Contains(errMsg, "access denied") {
		return "PermissionError"
	}

	// Parse/validation errors
	if strings.Contains(errMsg, "parse") ||
		strings.Contains(errMsg, "unmarshal") ||
		strings.Contains(errMsg, "decode") ||
		strings.Contains(errMsg, "invalid syntax") ||
		strings.Contains(errMsg, "invalid argument") {
		return "ValidationError"
	}

	return "Error"
}

// debugLog logs debug messages only if REPLICATED_DEBUG is set
func debugLog(format string, args ...interface{}) {
	if os.Getenv("REPLICATED_DEBUG") == "true" || os.Getenv("REPLICATED_DEBUG") == "1" {
		fmt.Fprintf(os.Stderr, "[TELEMETRY DEBUG] "+format+"\n", args...)
	}
}
